/**
 * Класс QuickSort реализует алгоритм Быстрой Сортировки для списка ArrayList <T>
 * @param <T>
 */
public class QuickSort <T extends Comparable<T>> {

    /**
     * Метод sort рекурсивно применяет алгоритм быстрой сортировки списка ArrayList<T>
     * @param list это список, который нужно отсортировать
     * @param left это индекс маркера, который идёт в сторону опорного элемента по списку с левой стороны
     * @param right это индекс маркера, который идёт в сторону опорного элемента по списку с правой стороны
     */
    public void sort(ArrayList<T> list, int left, int right)

    {


            if (left < right) // Убедимся, что левый маркер находится слева от правого маркера
            {

                int pivotIndex = partition(list, left, right); // Рассчитываем индекс опорного элемента

                sort(list, left, pivotIndex); // Рекурсивно сортируем левый субсписок

                sort(list, pivotIndex + 1, right); // Рекурсивно сортируем правый субсписок
            }
        }

    /**
     * Метод partition разделяет список на подсписки и сортирует их с помощью алгоритма Быстрой Сортировки
     * @param list это список, который нужно разделить
     * @param left левый индекс-маркер
     * @param right правый индекс-маркер
     * @return возвращает элемент right, если он меньше элемента left
     */
        private int partition(ArrayList <T> list, int left, int right)
        {
            int pivotIndex = (left + right) / 2; // Берём средний элемент списка
            T pivotValue = list.get(pivotIndex); // Инициализация переменной со значением среднего элемента
            left--; // Двигаем левый маркер к левой границе списка
            right++; // Двигаем правый маркер к правой границе списка

            while (true)
            {
                // Перемещаем маркер от левой границы списка вперёд, пока не найдём элемент
                // Со значением больше, чем у опорного
                do left++; while (list.get(left).compareTo(pivotValue) < 0) ;

                // Перемещаем маркер от правой границы списка назад, пока не найдём элемент
                // Со значением меньше, чем у опорного
                do right--; while (list.get(right).compareTo(pivotValue) > 0) ;

                if (left >= right) return right;

                // Меняем местами значения элементов, на которые указывает левый и правый маркер
                T temp = list.get(left); // Создаём временную переменную для элемента под маркером left
                list.set(left,list.get(right)); // Перезаписываем элемент, меняем его на элемент под правым маркером
                list.set(right,temp); // Присваиваем элементу под правым маркером значение переменной temp
            }
        }
    }


